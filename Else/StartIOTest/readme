（这篇文章写得不好，但暂时先这样吧）

2014/8/18 21:13:03
好了，重新总结下 StartIo 。这个东西也弄清楚有几天了，之前也写了一份类似总结的东西，但我觉得那份总结无论是从叙述问题的方式上还是表达上都不够好，没有让人一看就清楚了这个东西到底是什么回事。所以今天重新写一份。

今天我们的大致思路是从我作为一个学习者第一眼看到这些东西时就产生的疑问为主线，重在讲自己的一些认识和看法，而不是相关源码和处理流程。不过我也会给出相关源码，然后代码中也有相关注释，大家需要的自己去看？OK，下面就让我们从我看到这东西的第一个疑问说起。

疑问一 StartIo Routine 是由谁调用的，或者说它运行的什么环境下，运行在什么上下文中？答：IoStartPacket 和 IoStartNextPacket 中都有对 StartIo Routine 的调用，而 IoStartPacket 是由 Dispatch Function 调用的，IoStartNextPacket 是由 StartIo Routine 或者 Cancel Routine 调用的，所以从上述的调用关系我们可以看到，StartIo Routine 一般运行在同 Dispath Function 和 Cancel Routine 一样的上下文中。很奇怪是不是？确实是。最初对 StartIo 思考时，我觉得应该会有一个单独线程去处理这个 IRP 队列，应该说这是比较符合正常人的思路的。但事实却不是这样，没有单独的线程，StartIo Routine 通常情况下就运行在同 Dispath Function 一样的上下文中，没有什么单独的线程，这也许可以称之为巧妙，但也可以说让人理解其处理流程会很吃力。不过关于这一点，我就说这么多了，具体的流程什么的请大家自己去看源码。

疑问二 StartIo Routine 的目的是帮助我们串行化异步 IRP ，但它到底在那些方面帮助了我们？我们还需要做什么？答：从源码来看，我觉得 StartIo 给我们最大的帮助就是对 IRP 队列的管理，不需要我们自己去维护一个队列。但我觉得这也是它唯一做的事，可能有人会说它在IRP的正常完成过程和 Cancel Routine 之间的竞争关系上对我们也有帮助。但在这一点上，我并没有什么大的感觉。因为 StartIo Routine 和 Cancel Routine 之间还是需要手动去处理这种竞争关系，而且每种竞争关系下该做什么处理会让一个没看过 StartIo 相关的源码的人感到很困惑，这一点大家可以从示例代码上感受下。具体我就不多说了

OK，最后在说说我的其他一点想法。那就是StartIo到底是不是一个好的封装，好的处理方式？从我的角度来讲，我认为如果不考虑它的处理方式，我会认为它的封装很差劲。但这种封装方式真的和它内部的处理方式没有关系吗？换个说法说，是不是就是因为它的这种实现方式导致了现在这种封装，呈献给我们一个让人困惑重重的接口。我觉的，要不Microsoft就不要使用提供StartIo，要不就提供一种更容易让人理解的接口或者提供关于这种机制处理流程，处理思想的更多资源。

另外，假如我们不使用 StartIo ，而自己去完成关于IRP串行处理的相关东西，难吗？我觉得不难。核心处理应该就下面两点：

    1. 链表操作的同步处理
    2. 与 Cancle Routine 之间的同步处理

关于1无需多言。那2呢？真的很难处理吗？我觉的不难，特别是在看过eventsample之后。因为eventsample已经做了这样的处理，而且它处理了更复杂的同步问题。所以，我觉得应该可以自己开发出比 StartIo 更好的处理方式

相关代码地址：

IoStartPacket 和 IoStartNextPacket 
https://github.com/HDM1991/ExampleLearn/blob/master/WindowsResearchKernel-WRK/WRK-v1.2/base/ntos/io/iomgr/iosubs.c

IoStartPacket 和 IoStartNextPacket 调用的对 IRP 队列进行操作的相关函数(如 KeInsertDeviceQueue )
https://github.com/HDM1991/ExampleLearn/blob/master/WindowsResearchKernel-WRK/WRK-v1.2/base/ntos/ke/devquobj.c

示例代码
https://github.com/HDM1991/ExampleLearn/tree/master/Else/StartIOTest/NT_Driver/Driver.cpp